"use strict";Object.defineProperty(exports,"__esModule",{value:true});function _export(target,all){for(var name in all)Object.defineProperty(target,name,{enumerable:true,get:Object.getOwnPropertyDescriptor(all,name).get})}_export(exports,{get ForgeCanvas(){return ForgeCanvas},get registerFonts(){return registerFonts}});const _forgescript=require("@tryforge/forgescript");const _canvas=require("@napi-rs/canvas");const _nodefs=require("node:fs");const _nodepath=require("node:path");const _undici=require("undici");const _packagejson=require("../package.json");const _classes=_export_star(require("./classes"),exports);_export_star(require("./typings"),exports);function _export_star(from,to){Object.keys(from).forEach(function(k){if(k!=="default"&&!Object.prototype.hasOwnProperty.call(to,k)){Object.defineProperty(to,k,{enumerable:true,get:function(){return from[k]}})}});return from}async function registerFonts(fonts,log){for(const font of fonts){if(!(0,_nodefs.existsSync)(font.src)){if(log)throw new Error(`Invalid font source: ${font.src}`);return}if((0,_nodefs.statSync)(font.src).isFile()){let filename=(0,_nodepath.basename)(font.src);if(!["ttf","otf","woff","woff2"].find(x=>filename.endsWith(`.${x}`)))return;filename=font.name??filename.slice(0,filename.lastIndexOf("."));if(log&&_canvas.GlobalFonts.has(filename))_forgescript.Logger.warn(`Font with name '${filename}' already exists`);if(!filename?.length)throw new Error(`Font name cannot be empty: ${font.src}`);if(filename.includes(","))throw new Error(`Font name cannot contain commas: ${filename}`);if(!_canvas.GlobalFonts.register((0,_nodefs.readFileSync)(font.src),filename)&&log)return _forgescript.Logger.warn(`Failed to register font: ${filename} (${font.src})`);_forgescript.Logger.info(`Registered a font: ${filename} (${font.src})`)}else return registerFonts((0,_nodefs.readdirSync)(font.src).map(x=>({src:(0,_nodepath.join)(font.src,x)})),log)}}let ForgeCanvas=class ForgeCanvas extends _forgescript.ForgeExtension{init(client){this.load(__dirname+"/functions");client.preloadImages=new _classes.ImageManager}constructor(...args){super(...args),this.name="forge.canvas",this.description=_packagejson.description,this.version=_packagejson.version}};_canvas.Image.prototype.getBuffer=async function(){let buffer;if(this.src instanceof Uint8Array)return Buffer.from(this.src);if(typeof this.src==="string"){if(this.src.startsWith("data:")){const base64=this.src.split(",")[1];buffer=Buffer.from(base64,"base64")}else if(/https?:\/\//.test(this.src)){const response=await (0,_undici.fetch)(this.src);if(!response.ok)throw new Error(`Failed to fetch image from ${this.src}`);buffer=Buffer.from(await response.arrayBuffer())}else buffer=(0,_nodefs.readFileSync)(this.src)}else throw new Error("Invalid image source");return buffer};