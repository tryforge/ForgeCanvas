"use strict";Object.defineProperty(exports,"__esModule",{value:true});Object.defineProperty(exports,"default",{enumerable:true,get:function(){return _default}});const _forgescript=require("@tryforge/forgescript");const _gifsx=require("@gifsx/gifsx");const _undici=require("undici");const _promises=require("node:fs/promises");const _=require("../..");const _default=new _forgescript.NativeFunction({name:"$newGIFDecoder",aliases:["$createGIFDecoder","$createDecoder","$GIFDecoder","$newDecoder"],description:"Creates a new GIF Decoder.",version:"1.2.0",brackets:true,unwrap:true,args:[{name:"gif",description:"Name of the new GIF Decoder.",type:_forgescript.ArgType.String,required:true,rest:false},{name:"path",description:"Path to the GIF file.",type:_forgescript.ArgType.String,required:true,rest:false},{name:"options",description:"Options for the GIF Decoder.",type:_forgescript.ArgType.String,required:false,rest:false}],async execute(ctx,[name,path,options]){if(!ctx.gifManager||!(ctx.gifManager instanceof _.GIFManager))ctx.gifManager=new _.GIFManager;let gif;if(path.startsWith("http://")||path.startsWith("https://")){const response=await (0,_undici.fetch)(path);if(!response.ok)return this.customError(`Failed to fetch ${path}`);gif=await response.arrayBuffer()}else if(path.startsWith("encoder://")){const encoder=ctx.gifManager.getEncoder(path.slice(10));if(!encoder)return this.customError(_.FCError.NoEncoder);gif=encoder.getBuffer()}else gif=await (0,_promises.readFile)(path,null);ctx.gifManager.setDecoder(name,new _gifsx.Decoder(Buffer.from(gif),options?ctx.gifManager.getDecodeOptions(options):undefined));return this.success()}});